/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) =>
  __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (
    (module2 && typeof module2 === "object") ||
    typeof module2 === "function"
  ) {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {
          get: () => module2[key],
          enumerable:
            !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable,
        });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(
    __markAsModule(
      __defProp(
        module2 != null ? __create(__getProtoOf(module2)) : {},
        "default",
        module2 && module2.__esModule && "default" in module2
          ? { get: () => module2.default, enumerable: true }
          : { value: module2, enumerable: true }
      )
    ),
    module2
  );
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) =>
      x.done
        ? resolve(x.value)
        : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  PopoverSelectString: () => PopoverSelectString,
  askSelectString: () => askSelectString,
  default: () => ScrewDriverPlugin,
});
var import_obsidian = __toModule(require("obsidian"));
function getFiles(app, path, ignoreList, filter) {
  return __async(this, null, function* () {
    const w = yield app.vault.adapter.list(path);
    let files = [
      ...w.files
        .filter((e) => !ignoreList.some((ee) => e.endsWith(ee)))
        .filter((e) => !filter || filter.some((ee) => e.match(ee))),
    ];
    L1: for (const v of w.folders) {
      for (const ignore of ignoreList) {
        if (v.endsWith(ignore)) {
          continue L1;
        }
      }
      files = files.concat(yield getFiles(app, v, ignoreList, filter));
    }
    return files;
  });
}
function getDirectories(app, path, ignoreList) {
  return __async(this, null, function* () {
    const w = yield app.vault.adapter.list(path);
    let dirs = [];
    L1: for (const v of w.folders) {
      for (const ignore of ignoreList) {
        if (v.endsWith(ignore)) {
          continue L1;
        }
      }
      dirs = dirs.concat([v]);
      dirs = dirs.concat(yield getDirectories(app, v, ignoreList));
    }
    return dirs;
  });
}
function isPlainText(filename) {
  if (filename.endsWith(".md")) return true;
  if (filename.endsWith(".txt")) return true;
  if (filename.endsWith(".svg")) return true;
  if (filename.endsWith(".html")) return true;
  if (filename.endsWith(".csv")) return true;
  if (filename.endsWith(".css")) return true;
  if (filename.endsWith(".js")) return true;
  if (filename.endsWith(".json")) return true;
  if (filename.endsWith(".xml")) return true;
  if (filename.endsWith(".ts")) return true;
  if (filename.endsWith(".canvas")) return true;
  return false;
}
function ensureDirectory(app, fullpath) {
  return __async(this, null, function* () {
    const pathElements = fullpath.split("/");
    pathElements.pop();
    let c = "";
    for (const v of pathElements) {
      c += v;
      try {
        yield app.vault.createFolder(c);
      } catch (ex) {
        if (ex.message && ex.message == "Folder already exists.") {
        } else {
          new import_obsidian.Notice("Folder Create Error");
          console.log(ex);
        }
      }
      c += "/";
    }
  });
}
var ScrewDriverPlugin = class extends import_obsidian.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addCommand({
        id: "screwdriver-add-target-dir",
        name: "対象ディレクトリを追加",
        editorCallback: (editor, view) =>
          __async(this, null, function* () {
            const list = yield getDirectories(
              this.app,
              this.app.vault.configDir,
              ["node_modules", ".git"]
            );
            const selected = yield askSelectString(
              this.app,
              "対象ディレクトリを選択",
              list
            );
            if (selected) {
              let filters = [];
              if (selected.indexOf("plugins") !== -1) {
                if (
                  (yield askSelectString(
                    this.app,
                    "プラグインのデータを含めますか？",
                    ["はい", "いいえ"]
                  )) == "yes"
                ) {
                  filters = [
                    "main\\.js$",
                    "manifest\\.json$",
                    "styles\\.css$",
                    "data\\.json$",
                  ];
                } else {
                  filters = ["main\\.js$", "manifest\\.json$", "styles\\.css$"];
                }
              } else if (selected.indexOf("themes") !== -1) {
                filters = ["manifest\\.json$", "theme\\.css$"];
              } else if (selected.indexOf("snippets") !== -1) {
                filters = (yield getFiles(
                  this.app,
                  selected,
                  [],
                  [/\.css$/]
                )).map(
                  (e) =>
                    e
                      .substring(selected.length)
                      .replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "$"
                );
              }
              this.app.fileManager.processFrontMatter(view.file, (fm) =>
                __async(this, null, function* () {
                  var _a, _b;
                  fm.targets = [
                    ...new Set([
                      ...((_a = fm.targets) != null ? _a : []),
                      selected,
                    ]),
                  ];
                  if (filters.length > 0) {
                    fm.filters = [
                      ...new Set([
                        ...((_b = fm.filters) != null ? _b : []),
                        ...filters,
                      ]),
                    ];
                  }
                })
              );
            }
          }),
      });
      this.addCommand({
        id: "screwdriver-create-template-dump",
        name: "ローカルファイルのエクスポートテンプレートを作成または追加",
        editorCallback: (editor, view) =>
          __async(this, null, function* () {
            this.app.fileManager.processFrontMatter(view.file, (fn) => {
              var _a, _b, _c, _d, _e;
              fn.targets = (_a = fn.targets) != null ? _a : [];
              fn.ignores =
                (_b = fn.ignores) != null ? _b : ["/node_modules", "/.git"];
              fn.filters = (_c = fn.filters) != null ? _c : [];
              fn.comment =
                (_d = fn.comment) != null
                  ? _d
                  : "対象を追加するには'対象ディレクトリを追加'を選択";
              fn.tags = (_e = fn.tags) != null ? _e : [];
            });
          }),
      });
      this.addCommand({
        id: "screwdriver-create-template-fetch",
        name: "リモートファイルの取得テンプレートを作成または追加",
        editorCallback: (editor, view) =>
          __async(this, null, function* () {
            this.app.fileManager.processFrontMatter(view.file, (fn) => {
              var _a, _b, _c, _d;
              fn.urls = (_a = fn.urls) != null ? _a : [];
              fn.authorization = (_b = fn.authorization) != null ? _b : "";
              fn.tags = (_c = fn.tags) != null ? _c : [];
              fn.header_json = (_d = fn.header_json) != null ? _d : "";
            });
          }),
      });
      this.addCommand({
        id: "screwdriver-dump",
        name: "指定されたファイルをエクスポートしてアクティブファイルに保存",
        editorCallback: (editor, view) =>
          __async(this, null, function* () {
            var _a, _b, _c;
            const data = view.data;
            const bodyStartIndex = data.indexOf("\n---");
            if (!data.startsWith("---") || bodyStartIndex === -1) {
              new import_obsidian.Notice("フロントマターが見つかりませんでした。");
            }
            const yaml = data.substring(3, bodyStartIndex);
            const yamlData = (0, import_obsidian.parseYaml)(yaml);
            let newData = "---" + yaml + "\n---\n\n";
            const target = (_a = yamlData.target) != null ? _a : "";
            let targets = (_b = yamlData.targets) != null ? _b : [];
            if (target) targets = [...targets, target];
            targets = targets.map((e) => e.trim()).filter((e) => e != "");
            const ignoresSrc = yamlData.ignores;
            const ignores = Array.isArray(ignoresSrc)
              ? ignoresSrc
              : (ignoresSrc + "").split(",");
            const filterSrc = yamlData.filters;
            const filters = !filterSrc
              ? null
              : filterSrc.map((e) => new RegExp(e));
            const urls = (_c = yamlData.urls) != null ? _c : "";
            if (targets.length == 0 && urls == "") {
              new import_obsidian.Notice(
                "対象フォルダまたはURLが指定されていません。"
              );
              return;
            }
            for (const url of urls) {
              try {
                let fileDat = "";
                let bin = false;
                const w = yield (0, import_obsidian.requestUrl)(url);
                const filename = new URL(url).pathname.split("/").last();
                const dt = w.arrayBuffer;
                try {
                  const text = new TextDecoder("utf-8", { fatal: true }).decode(
                    dt
                  );
                  fileDat = text;
                  fileDat = fileDat.replace(/\\/g, "\\\\");
                  fileDat = fileDat.replace(/`/g, "\\`");
                } catch (ex2) {
                  fileDat = yield (0, import_obsidian.arrayBufferToBase64)(dt);
                  bin = true;
                }
                newData += "\n";
                newData += `# ${url} 
`;
                newData += `- Fetched :${new Date().toLocaleString()} 
`;
                newData +=
                  "\n```screwdriver:" + filename + (bin ? ":bin" : "") + "\n";
                newData += fileDat + "";
                newData += "\n```";
              } catch (ex) {
                new import_obsidian.Notice(`"取得エラー："${url}
${ex}`);
              }
            }
            for (const target2 of targets) {
              const files = yield getFiles(this.app, target2, ignores, filters);
              for (const file of files) {
                let fileDat = "";
                let bin = false;
                const dt = yield this.app.vault.adapter.readBinary(file);
                const stat = yield this.app.vault.adapter.stat(file);
                try {
                  const text = new TextDecoder("utf-8", { fatal: true }).decode(
                    dt
                  );
                  fileDat = text;
                  fileDat = fileDat.replace(/\\/g, "\\\\");
                  fileDat = fileDat.replace(/`/g, "\\`");
                } catch (ex2) {
                  fileDat = yield (0, import_obsidian.arrayBufferToBase64)(dt);
                  bin = true;
                }
                newData += "\n";
                newData += `# ${file} 
`;
                newData += `"- 作成日時："${new Date(stat.ctime).toLocaleString()} 
`;
                newData += `"- 更新日時："${new Date(stat.mtime).toLocaleString()} 
`;
                newData +=
                  "\n```screwdriver:" +
                  file +
                  ":" +
                  (bin ? "bin" : "plain") +
                  "\n";
                newData += fileDat + "";
                newData += "\n```";
              }
            }
            editor.setValue(newData);
          }),
      });
      this.registerMarkdownCodeBlockProcessor(
        "screwdriver",
        (source, el, ctx) => {
          const sourcePath = ctx.sourcePath;
          const si = ctx.getSectionInfo(el);
          const fxx = si.text.split("\n")[si.lineStart];
          const filename = `${fxx}:::`.split(":")[1];
          const rSource = `${"```\n"}${source}${"\n```"}`;
          const renderSource = `> [!screwdriver]- ${filename}
${rSource.replace(/^/gm, "> ")}`;
          const fx = el.createDiv({ text: "", cls: ["screwdriver-display"] });
          import_obsidian.MarkdownRenderer.renderMarkdown(
            renderSource,
            fx,
            sourcePath,
            this
          );
          el.replaceWith(fx);
        }
      );
      this.addCommand({
        id: "screwdriver-restore",
        name: "アクティブファイルからエクスポートされたファイルを復元",
        editorCallback: (editor, view) =>
          __async(this, null, function* () {
            const data = view.data;
            if (data.startsWith("---")) {
              const bodyStartIndex = data.indexOf("\n---");
              if (bodyStartIndex !== -1) {
                const preBlocks = data
                  .substring(bodyStartIndex)
                  .matchAll(
                    /^```(?:screwdriver:|)([\s\S]*?)\n([\s\S]*?)^```/gm
                  );
                for (const preBlock of preBlocks) {
                  const [, filenameSrc, data2] = preBlock;
                  const [filename, dataType] = `${filenameSrc}:`.split(":");
                  let saveData = data2;
                  try {
                    if (
                      (isPlainText(filename) && dataType != "bin") ||
                      dataType == "plain"
                    ) {
                      saveData = saveData.replace(/\\`/g, "`");
                      saveData = saveData.replace(/\\\\/g, "\\");
                      saveData = saveData.substring(
                        0,
                        saveData.lastIndexOf("\n")
                      );
                      yield ensureDirectory(this.app, filename);
                      yield this.app.vault.adapter.write(filename, saveData);
                    } else {
                      saveData = saveData.substring(
                        0,
                        saveData.lastIndexOf("\n")
                      );
                      const saveDataArrayBuffer = (0,
                      import_obsidian.base64ToArrayBuffer)(saveData);
                      yield ensureDirectory(this.app, filename);
                      yield this.app.vault.adapter.writeBinary(
                        filename,
                        saveDataArrayBuffer
                      );
                    }
                    new import_obsidian.Notice(
                      `"ファイル：${filename} がデバイスに書き込まれました。"`
                    );
                    console.log(
                      `"ファイル：${filename} がデバイスに書き込まれました。"`
                    );
                  } catch (ex) {
                    new import_obsidian.Notice(`"${filename} の書き込みに失敗しました"`);
                    console.error(`"${filename} の書き込みに失敗しました"`);
                    console.log(ex);
                  }
                }
                return;
              }
            }
            new import_obsidian.Notice("フロントマターが見つかりませんでした。");
            console.error("Frontmatter was not found");
          }),
      });
    });
  }
  onunload() {}
  loadSettings() {
    return __async(this, null, function* () {});
  }
  saveSettings() {
    return __async(this, null, function* () {});
  }
};
var PopoverSelectString = class extends import_obsidian.FuzzySuggestModal {
  constructor(app, note, placeholder, getItemsFun, callback) {
    super(app);
    this.callback = () => {};
    this.getItemsFun = () => {
      return ["はい", "いいえ"];
    };
    this.app = app;
    this.setPlaceholder((placeholder != null ? placeholder : "y/n) ") + note);
    if (getItemsFun) this.getItemsFun = getItemsFun;
    this.callback = callback;
  }
  getItems() {
    return this.getItemsFun();
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item, evt) {
    this.callback(item);
    this.callback = null;
  }
  onClose() {
    setTimeout(() => {
      if (this.callback != null) {
        this.callback("");
      }
    }, 100);
  }
};
var askSelectString = (app, message, items) => {
  const getItemsFun = () => items;
  return new Promise((res) => {
    const popover = new PopoverSelectString(
      app,
      message,
      "",
      getItemsFun,
      (result) => res(result)
    );
    popover.open();
  });
};

/* nosourcemap */
